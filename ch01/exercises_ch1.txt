1. This function uses a combination SCAS and STOS to do its work. First, explain
what is the type of the [EBP+8] and [EBP+C] in line 1 and 8, respectively. Next,
explain what this snippet does.

01: mov edi, [ebp+8]
02: mov edx, edi
03: xor eax, eax
04: or ecx, 0FFFFFFFFh
05: repne scasb
06: add ecx, 2
07: neg ecx
08: mov al, [ebp+0Ch]
09: mov edi, edx
10: rep stosb
11: mov eax, edx

[EBP+8] is a pointer to a string, while [EBP+C] is a pointer to a char.
At 01, the code loads the first string character into edi, from the address at [EBP+8]
(which is ususally using CDECL convention the first parameter to a function passed using
the stack into x86_32 architecture), then the eax register is zeroed at 03. At 04, the ecx
register is masked against 0xFFFFFFF which puts the register word to a value of all 1's.
At 05 the repne instruction scans starting from edi into forward direction a byte at time
searching for the value contained into eax which is actually the null byte (the common
value for string termination in ascii). REPNE also decrements the value of ecx by one
at each iteration. REPNE and SCASB also sets the zero flag. So when the flag is setted
or ecx arrives at zero iteration stops.
At 06 ecx gets incremented by 2 and at 07 gets negated so it marks the position just after
the null byte. The char at [EBP+12] (which using CDECL is also the second parameter to this
function) is copied into eax, at 09 the edi points again to the first character of the string.
At 10 REP STOSB is called starting counting down from the value actually contained in ecx, and
filling the string with che char cotained into al register.
At 11 the the new string filled with the character into al is returned into eax.
This snippet of code let me think about the memset() function.

------------------------------------------------------------------------------------------------

1. Given what you learned about CALL and RET, explain how you would read
the value of EIP? Why can't you just do MOV EAX, EIP?

The value of EIP is directly modified using the CALL or the RET instruction,
so it is not possible to modify it by MOV operations and alter directly the
execution flow of the program.
By the way a possible trick to read the EIP value which a function will issue on
return is to grab it from the stack, for example using the following snippet of code:

        section .text
        global _start
_start:
        call get_eip
        mov eax, 0x1
        mov ebx, 0x0
        int 0x80
get_eip:
        push ebp
        mov ebp, esp
        mov ebx, [esp+4]
        leave
        ret

The CALL instruction, will put the EIP value on the stack, from the get_eip
function is possible to get this value at [ESP+4].
Another trick used into payload decoding function sometimes is of course the following:

_start:
        jmp short _target
_get_eip:
        pop esi
_target:
        call _get_eip

Executing a short jump to _target which calls _get_eip putting the address of the
current EIP on the stack and finally popping it into a register (in this case esi).

-------------------------------------------------------------------------------------------

2. Come up with at least two code sequences to set EIP to 0xAABBCCDD.

First example:

        section .text
        global _start
_start:
        call alter_me
        mov eax, 0x1
        mov ebx, 0x0
        int 0x80
alter_me:
        push ebp
        mov ebp, esp
        mov esp, ebp
        pop ebp
        push 0xAABBCCDD
        ret

Into the first example, the solution is to push on the stack, after the
function epilogue of alter_me the desired address for the EIP. The RET
instruction will pop it from the top of the stack and will put it into
the EIP register.

Second example:

        section .text
        global _start
_start:
        push 0xAABBCCDD
        call alter_me
alter_me:
        push ebp
        mov ebp,esp
        mov esp,ebp
        pop ebp
        pop ebx
        ret

The second example's solution is specular respect the first. The desired address,
is pushed onto the stack before the CALL instruction to alter_me.
At the function epilogue of alter_me, after the usual pop ebp, before the RET instruction
is issued getting the into ebx the top of the stack that is the real EIP address.
In this manner, at the top of the stacks remains the value 0xAABBCCDD so when the
RET is executed the value 0xAABBCCDD is stored into the EIP register.

----------------------------------------------------------------------------------------------

3. In the example function, addme, what would happen if the stack pointer were
not properly restored before executing RET?

Into the function's body after the function prologue the stack is untouched, no
space for local vars is allocated.
So nothing happens.

-----------------------------------------------------------------------------------------------

4. In all of the calling conventions explained, the return value is stored in a 32
bit register (EAX). What happens when the return value does not fit in a 32-bit
register? Write a program to experiment and evaluate your answer. Does the
mechanism change from compiler to compiler?

Here a simple snippet of code which uses a function to return a value (called test struct)
bigger than 32 bits:

#include <stdio.h>
#include <stdlib.h>

struct test {
  unsigned int a;
  unsigned int b;
  unsigned int c;
};


static struct test
test_return(void)
{
  struct test ret_test;
  ret_test.a = 0x1;
  ret_test.b = 0x2;
  ret_test.c = 0x3;
  return ret_test;
}
    
int
main(int argc, char *argv[])
{
  struct test my_test;
  my_test = test_return();
  printf("%d %d %d\n",my_test.a, my_test.b, my_test.c);
  return 0;
}

The first disassebly which follows here is about the test_function() and
the code is compiled using gcc 4.8.2:

<test_return>:
        01:	55	        push   ebp
        02:	89 e5                   mov    ebp,esp
        03:	83 ec 10                sub    esp,0x10
        04:	c7 45 f4 01 00 00 00    mov    DWORD PTR [ebp-0xc],0x1
        05:	c7 45 f8 02 00 00 00    mov    DWORD PTR [ebp-0x8],0x2
        06:	c7 45 fc 03 00 00 00    mov    DWORD PTR [ebp-0x4],0x3
        07:	8b 45 08                mov    eax,DWORD PTR [ebp+0x8]
        08:	8b 55 f4                mov    edx,DWORD PTR [ebp-0xc]
        09:	89 10                   mov    DWORD PTR [eax],edx
        10:	8b 55 f8                mov    edx,DWORD PTR [ebp-0x8]
        11:	89 50 04                mov    DWORD PTR [eax+0x4],edx
        12:	8b 55 fc                mov    edx,DWORD PTR [ebp-0x4]
        13:	89 50 08                mov    DWORD PTR [eax+0x8],edx
        14:	8b 45 08                mov    eax,DWORD PTR [ebp+0x8]
        15:	c9                      leave  
        16:	c2 04 00                ret    0x4

From 01 to 02, the usual function prologue is builded. At 03 space on
the stack is reserved for ret_struct, it's 16 bytes despite the fact
ret_struct is 12 bytes because compiler padding.
From 04 to 06 ret_struct is filled in reverse order.
At 07 into eax gets loaded the address of my_test declared into the
main() function.
From 08 to 13, ret_struct fields are copied into my_test struct
using the edx register to hold the current field to copy.
At 14, the eax gets filled again with the my_test struct address,
which now has the fields of ret_struct.
So the stack is used to return values bigger than 32 bits, and the
eax points to the first address on the stack which references the
result.

------------------------------------------------------------------------------------------------------
