1. This function uses a combination SCAS and STOS to do its work. First, explain
what is the type of the [EBP+8] and [EBP+C] in line 1 and 8, respectively. Next,
explain what this snippet does.

01: mov edi, [ebp+8]
02: mov edx, edi
03: xor eax, eax
04: or ecx, 0FFFFFFFFh
05: repne scasb
06: add ecx, 2
07: neg ecx
08: mov al, [ebp+0Ch]
09: mov edi, edx
10: rep stosb
11: mov eax, edx

[EBP+8] is a pointer to a string, while [EBP+C] is a pointer to a char.
At 01, the code loads the first string character into edi, from the address at [EBP+8]
(which is ususally using CDECL convention the first parameter to a function passed using
the stack into x86_32 architecture), then the eax register is zeroed at 03. At 04, the ecx
register is masked against 0xFFFFFFF which puts the register word to a value of all 1's.
At 05 the repne instruction scans starting from edi into forward direction a byte at time
searching for the value contained into eax which is actually the null byte (the common
value for string termination in ascii). REPNE also decrements the value of ecx by one
at each iteration. REPNE and SCASB also sets the zero flag. So when the flag is setted
or ecx arrives at zero iteration stops.
At 06 ecx gets incremented by 2 and at 07 gets negated so it marks the position just after
the null byte. The char at [EBP+12] (which using CDECL is also the second parameter to this
function) is copied into eax, at 09 the edi points again to the first character of the string.
At 10 REP STOSB is called starting counting down from the value actually contained in ecx, and
filling the string with che char cotained into al register.
At 11 the the new string filled with the character into al is returned into eax.
This snippet of code let me think about the memset() function.

------------------------------------------------------------------------------------------------

1. Given what you learned about CALL and RET, explain how you would read
the value of EIP? Why can't you just do MOV EAX, EIP?

The value of EIP is directly modified using the CALL or the RET instruction,
so it is not possible to modify it by MOV operations and alter directly the
execution flow of the program.
By the way a possible trick to read the EIP value which a function will issue on
return is to grab it from the stack, for example using the following snippet of code:

        section .text
        global _start
_start:
        call get_eip
        mov eax, 0x1
        mov ebx, 0x0
        int 0x80
get_eip:
        push ebp
        mov ebp, esp
        mov ebx, [esp+4]
        leave
        ret

The CALL instruction, will put the EIP value on the stack, from the get_eip
function is possible to get this value at [ESP+4].
Another trick used into payload decoding function sometimes is of course the following:

_start:
        jmp short _target
_get_eip:
        pop esi
_target:
        call _get_eip

Executing a short jump to _target which calls _get_eip putting the address of the
current EIP on the stack and finally popping it into a register (in this case esi).

-------------------------------------------------------------------------------------------

2. Come up with at least two code sequences to set EIP to 0xAABBCCDD.

First example:

        section .text
        global _start
_start:
        call alter_me
        mov eax, 0x1
        mov ebx, 0x0
        int 0x80
alter_me:
        push ebp
        mov ebp, esp
        mov esp, ebp
        pop ebp
        push 0xAABBCCDD
        ret

Into the first example, the solution is to push on the stack, after the
function epilogue of alter_me the desired address for the EIP. The RET
instruction will pop it from the top of the stack and will put it into
the EIP register.

Second example:

        section .text
        global _start
_start:
        push 0xAABBCCDD
        call alter_me
alter_me:
        push ebp
        mov ebp,esp
        mov esp,ebp
        pop ebp
        pop ebx
        ret

The second example's solution is specular respect the first. The desired address,
is pushed onto the stack before the CALL instruction to alter_me.
At the function epilogue of alter_me, after the usual pop ebp, before the RET instruction
is issued getting the into ebx the top of the stack that is the real EIP address.
In this manner, at the top of the stacks remains the value 0xAABBCCDD so when the
RET is executed the value 0xAABBCCDD is stored into the EIP register.

----------------------------------------------------------------------------------------------

3. In the example function, addme, what would happen if the stack pointer were
not properly restored before executing RET?

Into the function's body after the function prologue the stack is untouched, no
space for local vars is allocated.
So nothing happens.

-----------------------------------------------------------------------------------------------

4. In all of the calling conventions explained, the return value is stored in a 32
bit register (EAX). What happens when the return value does not fit in a 32-bit
register? Write a program to experiment and evaluate your answer. Does the
mechanism change from compiler to compiler?

Of course an integer overflow occurs, the following example demonstrates the problem:

        section .text
        global _start
_start:
        call smash_return
        mov ecx, eax
        mov eax, 0x1
        mov ebx, 0x0
        int 0x80
smash_return:
        push ebp
        mov ebp, esp
        mov eax, 0xFFFFFFFF
        add eax, 0x3
        mov esp, ebp
        pop ebp
        ret

Into smash_return the eax value is filled with the maximum integer value,
0xFFFFFFFF. After that it is incremented by 0x3. The value of eax after this addition
becames 0x2. It is possible to verify this condition for example using gdb and setting
a breakpoint at the line "mov ecx, eax", just after the function returns.

------------------------------------------------------------------------------------------------------

Exercises based on Windows code into the loop sections etc. will be done not so quickly because I have
no time to do it now, like configuring the debugging environment and so on...
So quickly I'll publish solutions based on x86_64 after this section and solutions based on ARM arch.

------------------------------------------------------------------------------------------------------
